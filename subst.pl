#!/usr/bin/perl
#
# $Id: subst.pl,v 4.7 1998/01/28 22:00:10 mj Exp $
#
# Substitute directory names for FIDOGATE scripts
#

if($#ARGV < 0) {
    print STDERR
	"usage:   subst.pl [-p] [-c config.make] [-v] [-h] [-HC] source ...\n",
	"\n",
	"options:   -d              dump config parameters from config.make\n",
	"           -p              replace 1st line with \#!PERL\n",
	"           -c config.make  use specified config.make\n",
	"           -v              verbose\n",
	"           -h              generate paths.h\n",
	"           -H              generate cf_funcs.h\n",
	"           -C              generate cf_funcs.c\n",
	"           -A              generate cf_abbrev.c\n",
	"           -E              generate cf_env.c\n";
    exit 1;
}


require "getopts.pl";
&Getopts('dpc:vhHCAE');

$config = $opt_c ? $opt_c : "config.make";



##### Write cf_funcs.h #######################################################

sub cf_funcs_h {
    local($key) = @_;

    $lkey = $key;
    $lkey =~ tr/A-Z/a-z/;

    print
	"char *cf_p_$lkey(void);\n",
	"char *cf_s_$lkey(char *);\n";
}



##### Write cf_funcs.c #######################################################

sub cf_funcs_c {
    local($key) = @_;

    $lkey = $key;
    $lkey =~ tr/A-Z/a-z/;

    print
	"/***** $key *****/\n";
    print
	"static char *cf_p_s_$lkey(char *s)\n",
	"{\n",
	"    static char *pval = NULL;\n",
	"    if(s)\n",
	"        pval = strsave(s);\n",
	"    if(! pval)\n",
	"    {\n",
	"	if( ! (pval = cf_get_string(\"$key\", TRUE)) )\n",
	"	    pval = DEFAULT_$key;\n",
	"	debug(8, \"config: $key %s\", pval);\n",
	"    }\n",
	"    return pval;\n",
	"}\n",
	"char *cf_p_$lkey(void)\n",
	"{\n",
	"    return cf_p_s_$lkey(NULL);\n",
	"}\n",
	"char *cf_s_$lkey(char *s)\n",
	"{\n",
	"    return cf_p_s_$lkey(s);\n",
	"}\n\n";
}



##### Write cf_env.c #########################################################

sub cf_env_c {
    local($key) = @_;

    $lkey = $key;
    $lkey =~ tr/A-Z/a-z/;

    print
	"    if( (p = getenv(\"FIDOGATE_$key\")) )\n",
	"        cf_s_$lkey(p);\n";
}



##### Main ###################################################################

# Read config.make
open(P, "$config") || die "can't open config.make\n";

undef %macros;
undef %macros_v;
undef %subst;

while(<P>) {
    chop;
    next if( /^\s\#/ );
    s/\#.*$//;

    if( /^\s*DEFAULT_F_([A-Z0-9_]+)\s*=\s*(.*)\s*$/ ) {
	print "subst: $1=$2\n" if($opt_v);
	$macros{$1} = $2;
    }
    elsif( /^\s*DEFAULT_V_([A-Z0-9_]+)\s*=\s*(.*)\s*$/ ) {
	print "subst: $1=$2\n" if($opt_v);
	$macros{$1} = $2;
	$macros_v{$1} = 1;
    }
    elsif( /^\s*DEFAULT_A_([A-Z0-9_]+)\s*=\s*%(.)\s*$/ ) {
	print "subst: $1=%$2\n" if($opt_v);
	$abbrevs{$1} = $2;
    }
    elsif( /^\s*PERL\s*=\s*(.*)\s*$/ ) {
	print "subst: perl=$1\n" if($opt_v);
	$perl = $1;
    }
    elsif( /^\s*([A-Z0-9_]+)\s*=\s*(.*)\s*$/ ) {
	# all other macros in config.make
	$subst{$1} = $2 if(! $macros{$1});
    }
}
close(P);

# Resolve macros (only 1 level allowed)
for $s (keys %macros) {
    $r = $macros{$s};
    if( $r =~ /\$\((.*)\)/ ) {
	$o = $1;
	$m = $1;
	$m =~ s/^DEFAULT_(._)?//;
	$r =~ s/\$\($o\)/$macros{$m}/;
	$macros{$s} = $r;
	print "subst: $s=$r\n" if($opt_v);
    }
}



# Dump parameters
if($opt_d) {
    for $s (keys %macros) {
	print
	    "$s ", ($macros_v{$s} ? "(variable)" : "(fixed)"),
	    " = $macros{$s}\n";
    }
    for $s (keys %abbrevs) {
	print
	    "%$abbrevs{$s} = $s\n";
    }
    print "perl = $perl\n";

    exit 0;
}



# Write cf_funcs.h
if($opt_H) {
    print
	"/* Automatically generated by subst.pl --- DO NOT EDIT!!! */\n\n",
	"/*\n",
	" * FIDOGATE\n",
	" *\n",
	" * \$Id\$\n",
	" */\n\n";
    
    for $s (keys %macros) {
	&cf_funcs_h($s) if($macros_v{$s});
    }

    exit 0;
}



# Write cf_funcs.c
if($opt_C) {
    print
	"/* Automatically generated by subst.pl --- DO NOT EDIT!!! */\n\n",
	"/*\n",
	" * FIDOGATE\n",
	" *\n",
	" * \$Id\$\n",
	" */\n\n",
	"\#include \"fidogate.h\"\n\n";
    
    for $s (keys %macros) {
	&cf_funcs_c($s) if($macros_v{$s});
    }

    exit 0;
}



# Write paths.h
if($opt_h) {

    print
	"/* Automatically generated by subst.pl --- DO NOT EDIT!!! */\n\n",
	"/*\n",
	" * FIDOGATE\n",
	" *\n",
	" * \$Id\$\n",
	" */\n\n";

    for $s (keys %macros) {
	$r = $macros{$s};
	printf "#define DEFAULT_%-23s \"%s\"\n", $s, $r;
    }

    exit 0;
}



# Write cf_abbrev.c
if($opt_A) {
    print
	"/* Automatically generated by subst.pl --- DO NOT EDIT!!! */\n\n",
	"/*\n",
	" * FIDOGATE\n",
	" *\n",
	" * \$Id\$\n",
	" */\n\n";

    for $s (keys %abbrevs) {
	$ls = $s;
	$ls =~ tr/A-Z/a-z/;
	$r = $abbrevs{$s};
	printf "{ '$r', cf_p_$ls },\n", $s, $r;
    }

    exit 0;
}



# Write cf_env.c
if($opt_E) {
    print
	"/* Automatically generated by subst.pl --- DO NOT EDIT!!! */\n\n",
	"/*\n",
	" * FIDOGATE\n",
	" *\n",
	" * \$Id\$\n",
	" */\n\n";

    for $s (keys %macros) {
	&cf_env_c($s) if($macros_v{$s});
    }
    exit 0;
}



# Generate code
sub gen_code {
    local($name) = @_;

    if($name eq "perl-default") {
	print "##Automatically generated by subst.pl, DO NOT EDIT!!!##\n";
	for $s (keys %macros) {
	    $r = $macros{$s};
	    $s =~ tr/A-Z/a-z/;
	    print "\t\"$s\", \"$r\",\n";
	}
    }

    if($name eq "perl-abbrev") {
	print "##Automatically generated by subst.pl, DO NOT EDIT!!!##\n";
	for $s (keys %abbrevs) {
	    $r = $abbrevs{$s};
	    $s =~ tr/A-Z/a-z/;
	    print "\t\"$r\", \"$s\",\n";
	}
    }
}


# perl interpreter
if($opt_p) {
    $_ = <>;
    print "#!$perl\n";
}

# Substitute
while(<>) {

    if( /^\s*<GEN ([A-Za-z_-]+)>\s*$/ ) {
	# Generate code
	&gen_code($1);
	next;
    }

    for $s (keys %macros) {
	$r = $macros{$s};
	s/<$s>/$r/g;
    }
    for $s (keys %subst) {
	$r = $subst{$s};
	s/<$s>/$r/g;
    }

    print;
}

exit 0;
